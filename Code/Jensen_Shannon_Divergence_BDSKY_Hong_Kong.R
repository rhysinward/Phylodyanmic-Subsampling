# Notes and assumptions
# - load COVID incidence curves from WHO dashboard
# - estimate reproduction numbers with EpiFilter 

# Clean the workspace and console
closeAllConnections(); rm(list=ls())
cat("\014"); graphics.off()

# Set working directory to source
this.dir <- dirname(parent.frame(2)$ofile)
setwd(this.dir)
# Folder path for results
folres = paste0("./results/covid/")

# Main functions to run EpiFilter
files.sources = list.files(path = "./main")
for (i in 1:length(files.sources)) {
  source(paste0(c("./main/", files.sources[i]), collapse = ''))
}
# Load data from WHO for New Zealand
alldata = read.csv('Hong_Kong-COVID-19-data_updated.csv')
idcountry = which(alldata$Country == 'Hong Kong')

# Incidence and dates
Iday = alldata$New_cases[idcountry]
dates  = alldata$Date_reported[idcountry]
# Time series lengths
nday = length(dates); tday = 1:nday

# Approximate serial interval distribution from Ferguson et al
wdist = dgamma(tday, shape = 2.3669, scale = 2.7463)

# Total infectiousness
Lday = rep(0, nday) 
for(i in 2:nday){
  # Total infectiousness
  Lday[i] = sum(Iday[seq(i-1, 1, -1)]*wdist[1:(i-1)])    
}

######################################################################
## EpiFilter: provides formally smoothed and exact estimates
# Method based on Bayesian recursive filtering and smoothing
######################################################################

# Setup grid and noise parameters
Rmin = 0.01; Rmax = 10; eta = 0.1

# Uniform prior over grid of size m
m = 200; pR0 = (1/m)*rep(1, m)
# Delimited grid defining space of R
Rgrid = seq(Rmin, Rmax, length.out = m)

# Filtered (causal) estimates as list [Rmed, Rhatci, Rmean, pR, pRup, pstate]
Rfilt = epiFilter(Rgrid, m, eta, pR0, nday, Lday[tday], Iday[tday], 0.025)
# Causal predictions from filtered estimates [pred predci]
Ifilt = recursPredict(Rgrid, Rfilt[[4]], Lday[tday], Rfilt[[3]], 0.025)
#have an extra argument for twice maximum of incidence 
# Smoothed estimates as list of [Rmed, Rhatci, Rmean, qR]
Rsmooth = epiSmoother(Rgrid, m, Rfilt[[4]], Rfilt[[5]], nday, Rfilt[[6]], 0.025)
# Smoothed predictions from filtered estimates [pred predci]
Ismooth = recursPredict(Rgrid, Rsmooth[[4]], Lday[tday], Rsmooth[[3]], 0.025)

#plot rsmooth to see what it looks like (need to do for each time point)

Rgrid_gr <- 0.26*(Rgrid**(1/1.87)-1)

plot(Rgrid_gr, Rsmooth[[4]][1,])

#making sure it adds to one

sum( Rsmooth[[4]][1,])
length(Rsmooth[[4]][1,])
#upload PDF generated by tracer 
##unsampled##

#time 1

load('gr_density_unsampled.R')
data <- density_unsampled_hk

den <- density(data$V1)


#convert the PDF to a CDF 

pdf2cdf <- function(p, x=NULL, normalize=TRUE, expand=FALSE){
  if(is.null(x)) {
    if(is.atomic(p)){
      y <- p
      x <- seq(length(y))
    } else {
      stopifnot(exists("x", where=p) && exists("y", where=p))
      y <- p$y
      x <- p$x
    }
  } else {
    stopifnot(is.atomic(p) && is.atomic(x))
    y <- p
  }
  
  stopifnot(length(x)==length(y))
  stopifnot(length(x) > 2)
  stopifnot(all(is.finite(x)))
  stopifnot(all(is.finite(y)))
  stopifnot(all(diff(x) > 0))
  
  if(any(y < 0)){
    y[y < 0] <- 0
  }
  
  ## trapezoids: N = no., L = left height, R = right height, W = width
  N <- length(y) + 1
  L <- c(0,y)
  R <- c(y,0)
  W <- diff(x)
  W <- c(W[1], W, W[N-2])
  area <- W * (L + R) / 2
  cdf <- cumsum(area)
  
  if(normalize){
    cdf <- cdf / cdf[N]
  }
  if(expand){
    return(list(x=c(x[1]-W[1],x,x[N-1]+W[N]), y=c(0,cdf)))
  } else {
    return(list(x=x, y=cdf[-N]))
  }
}

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.


#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number

summary (d)

0.26*(10.025**(1/1.87)-1)

d <- seq(from = -0.018, to = 0.61, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:54

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

inMatrix <- rbind(combined$a,Rsmooth[[4]][1,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_unsampled_rt1 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_unsampled_rt1
#need to repeat for each time point 

#time point 2

den <- density(data$V2)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.018, to = 0.36, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:113

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)
plot(Rgrid_gr, Rsmooth[[4]][13,])

inMatrix <- rbind(combined$a,Rsmooth[[4]][13,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_unsampled_rt2 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_unsampled_rt2

#time point 3

den <- density(data$V3)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.09, to = 0.32, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:105

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][25,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][25,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_unsampled_rt3 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_unsampled_rt3

#time point 4

den <- density(data$V4)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.13, to = 0.02, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:166

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][37,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][37,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_unsampled_rt4 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_unsampled_rt4

#time 5

den <- density(data$V5)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.009, to = 0.562, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:68

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][49,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][49,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_unsampled_rt5 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_unsampled_rt5

#time 6

den <- density(data$V6)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.12, to = 0.124, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:144

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][61,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][55,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_unsampled_rt6 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_unsampled_rt6

#time 7

den <- density(data$V7)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.17, to = 0.572, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:28

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][73,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][44,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_unsampled_rt7 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_unsampled_rt7

JS_unsampled <- sum(JS_unsampled_rt1,JS_unsampled_rt2,JS_unsampled_rt3,JS_unsampled_rt4,JS_unsampled_rt5,JS_unsampled_rt6,JS_unsampled_rt7)/7
JS_unsampled


##uniform##

#time 1
load('gr_density_uniform.R')
data <- density_uniform_hk
den <- density(data$V1)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.134, to = 0.37, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:83

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][1,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][1,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_uniform_rt1 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_uniform_rt1
#need to repeat for each time point 

#time point 2

den <- density(data$V2)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.067, to = 0.28, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:120

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)
plot(Rgrid_gr, Rsmooth[[4]][13,])

inMatrix <- rbind(combined$a,Rsmooth[[4]][13,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_uniform_rt2 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_uniform_rt2

#time point 3

den <- density(data$V3)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.06, to = 0.25, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:128

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][25,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][22,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_uniform_rt3 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_uniform_rt3

#time point 4

den <- density(data$V4)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.09, to = 0.13, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:149

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][37,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][33,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_uniform_rt4 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_uniform_rt4

#time 5

den <- density(data$V5)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.08, to = 0.24, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:126

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][49,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][49,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_uniform_rt5 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_uniform_rt5

#time 6


den <- density(data$V6)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.09, to = 0.189, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:136

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][61,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][61,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_uniform_rt6 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_uniform_rt6

#time point 7

den <- density(data$V7)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.13, to = 0.35, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:89

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][49,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][73,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_uniform_rt7 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_uniform_rt7

JS_uniform <- sum(JS_uniform_rt1,JS_uniform_rt2,JS_uniform_rt3,JS_uniform_rt4,JS_uniform_rt5,JS_uniform_rt6,JS_uniform_rt7)/7
JS_uniform

##proportional##

#time 1
load('gr_density_proportional.R')
data <- density_uniform_hk
den <- density(data$V1)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.134, to = 0.375, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:82

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][1,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][1,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_proportional_rt1 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_proportional_rt1
#need to repeat for each time point 

#time point 2

den <- density(data$V2)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.067, to = 0.28, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:120

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)
plot(Rgrid_gr, Rsmooth[[4]][13,])

inMatrix <- rbind(combined$a,Rsmooth[[4]][13,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_proportional_rt2 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_proportional_rt2

#time point 3

den <- density(data$V3)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.06, to = 0.252, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:128

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][25,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][25,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_proportional_rt3 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_proportional_rt3

#time point 4

den <- density(data$V4)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.09, to = 0.13, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:149

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][33,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][33,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_proportional_rt4 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_proportional_rt4

#time 5

den <- density(data$V5)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.08, to = 0.242, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:126

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][49,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][49,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_proportional_rt5 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_proportional_rt5

#time 6

den <- density(data$V6)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.093, to = 0.189, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:135

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][61,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][61,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_proportional_rt6 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_proportional_rt6

#time 7


den <- density(data$V7)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.135, to = 0.35, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:88

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][73,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][73,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_proportional_rt7 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_proportional_rt7


JS_proportional <- sum(JS_proportional_rt1,JS_proportional_rt2,JS_proportional_rt3,JS_proportional_rt4,JS_proportional_rt5,JS_proportional_rt6,JS_proportional_rt7)/7
JS_proportional

#inverse

#time 1
load('gr_density_inverse.R')
data <- density_uniform_hk
den <- density(data$V1)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.135, to = 0.37, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:83

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][1,])

inMatrix <- rbind(combined$a,Rsmooth[[4]][1,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_inverse_rt1 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_inverse_rt1
#need to repeat for each time point 

#time point 2

den <- density(data$V2)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.067, to = 0.28, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:120

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)
plot(Rgrid_gr, Rsmooth[[4]][13,])

inMatrix <- rbind(combined$a,Rsmooth[[4]][13,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_inverse_rt2 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_inverse_rt2

#time point 3

den <- density(data$V3)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.06, to = 0.25, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:128

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][25,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][25,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_inverse_rt3 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_inverse_rt3

#time point 4

den <- density(data$V4)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.09, to = 0.13, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:149

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][37,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][37,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22

inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_inverse_rt4 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_inverse_rt4

#time 5

den <- density(data$V5)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.08, to = 0.24, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:126

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][49,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][49,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_inverse_rt5 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_inverse_rt5

#time 6

den <- density(data$V6)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.09, to = 0.189, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:136

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][61,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][61,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_inverse_rt6 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_inverse_rt6

#time 7

den <- density(data$V7)

#convert the PDF to a CDF 

cdf <- pdf2cdf(den[["y"]], x =den[["x"]] , normalize = TRUE, expand = FALSE)
cdf <- as.data.frame(cdf)
plot(cdf)

#code the cumulative probability of 0.025, 0.075 - 0.025 ect
#sum of probabilities cloest to 0.
#starting at 0.025, input values at 0.075 intervals 
#so need to select values from 0.025 and at each 0.05 interval from there and then subtract to get grid 200 and that is the PMF
which(abs(cdf$x-1)==min(abs(cdf$x-1)))

d <- as.numeric(cdf$x)

library(data.table)

a=data.table(Value=cdf$x)

a[,merge:=Value]

#want to start at 0.025 and increase in intervals of 0.05 and you want to get the values closest to this number
summary(d)
d <- seq(from = -0.14, to = 0.35, by = 0.0043)

b=data.table(Value=d)

b[,merge:=Value]

setkeyv(a,c('merge'))

setkeyv(b,c('merge'))

Merge_a_b=a[b,roll='nearest']

Merge_a_b

val <- as.data.frame(Merge_a_b)

library(dplyr)

#get only the values that correspond to the nearest associated value 

culm <- cdf %>% filter(x %in% val$Value)

culm_grid <- cbind(culm, d)

frequency <- as.data.frame(c(diff(culm_grid$y)))

#check to see if it adds to 1

sum(frequency)

#make sure the column lengths allign

add <- 1:87

add <- as.data.frame(replace(add, add>0, 0))

colnames(frequency)[1] <- "a"
colnames(add)[1] <- "a"

combined <- rbind(frequency,add)

#need to create a maxtrix

combined <- transform(combined, a = as.numeric(a))

plot(Rgrid_gr, combined$a)

plot(Rgrid_gr, Rsmooth[[4]][73,] )

inMatrix <- rbind(combined$a,Rsmooth[[4]][73,])

colnames(inMatrix)  <- c(1:200)

rownames(inMatrix) <- 1:2

pseudocount=1e-22


inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))

n <- 0.5 * (inMatrix[1,] + inMatrix[2,])
JS_inverse_rt7 <- 0.5 * (sum(inMatrix[1,] * log(inMatrix[1,] / n)) + sum(inMatrix[2,] * log(inMatrix[2,] / n)))
JS_inverse_rt7

JS_inverse <- sum(JS_inverse_rt1,JS_inverse_rt2,JS_inverse_rt3,JS_inverse_rt4,JS_inverse_rt5,JS_inverse_rt6,JS_inverse_rt7)/7
JS_inverse

JS_proportional
JS_inverse
JS_uniform
JS_unsampled
